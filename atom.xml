<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SongNing&#39;s Blog</title>
  
  <subtitle>Something will coming soon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://songning.me/"/>
  <updated>2017-04-02T03:34:40.000Z</updated>
  <id>http://songning.me/</id>
  
  <author>
    <name>SongNing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一步一步教你在JCenter发布开源库</title>
    <link href="http://songning.me/2016/12/23/upload-to-jcenter/"/>
    <id>http://songning.me/2016/12/23/upload-to-jcenter/</id>
    <published>2016-12-23T04:35:42.000Z</published>
    <updated>2017-04-02T03:34:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_register1.png" alt="register1"></p><p>当你写好了一个开源库，是否也想像其他的开源库一样在Android Studio中一句compile就可以引用。比如：</p><blockquote><p>compile ‘com.android.support:appcompat-v7:25.1.0’<a id="more"></a></p></blockquote><p>这看起来是一件很酷的事情，其实也不难。将你的项目上传Maven，然后发布到JCenter即可。下面我们来看看详细过程。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你要写好一个开源项目。嗯，不用我说你也知道。</p><h3 id="注册Bintray"><a href="#注册Bintray" class="headerlink" title="注册Bintray"></a>注册Bintray</h3><p>说到注册，大家第一时间肯定是想到去<a href="https://bintray.com/" target="_blank" rel="noopener">官网</a>注册。但是，现在官网首页的注册入口（上面第一张图）已经变成组织的注册了，并不是个人注册。所以我们要去个人注册入口：</p><blockquote><p>传送门：<a href="https://bintray.com/signup/oss" target="_blank" rel="noopener">https://bintray.com/signup/oss</a></p></blockquote><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_register2.png" alt="register2"></p><p>在上面这个页面注册就对了。也可以用第三方登录，我是直接用Github登录（好像其它两个在我国也登录不了），省事。</p><h3 id="创建一个Maven仓库"><a href="#创建一个Maven仓库" class="headerlink" title="创建一个Maven仓库"></a>创建一个Maven仓库</h3><p>注册完登录进去后，点击“Add New Repository”，新建仓库：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_create.png" alt="create"></p><p>接下来，我们会看到这么一个界面：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_create1.png" alt="create1"></p><p>Name填maven，Type选Maven，Default Licenses选Apache-2.0，Description是描述，随便填，点击Create。然后回到主页就会在刚刚“Add New Repository”下面多了一个叫maven的仓库。</p><h3 id="配置build-gradle"><a href="#配置build-gradle" class="headerlink" title="配置build.gradle"></a>配置build.gradle</h3><p>在你Project的build.gradle文件中加入Maven和Jfrog Bintray的依赖插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.2.3'</span></span><br><span class="line">        <span class="comment">//下面这两句</span></span><br><span class="line">        classpath <span class="string">'com.github.dcendents:android-maven-gradle-plugin:1.5'</span></span><br><span class="line">        classpath <span class="string">'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不一定要和我用同样版本的插件，说不定你用的时候就不是这个版本了。建议去Github上看看最新的版本：</p><blockquote><p>Maven：<a href="https://github.com/dcendents/android-maven-gradle-plugin" target="_blank" rel="noopener">https://github.com/dcendents/android-maven-gradle-plugin</a><br>Jfrog Bintray：<a href="https://github.com/bintray/gradle-bintray-plugin" target="_blank" rel="noopener">https://github.com/bintray/gradle-bintray-plugin</a></p></blockquote><p>然后在library的build.gradle文件中进行配置，这里以我的开源控件<a href="https://github.com/backkomyoung/CircleView" target="_blank" rel="noopener">CircleView</a>为例：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_gradle.png" alt="gradle"></p><p>整个build.gradle文件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.library'</span></span><br><span class="line"><span class="comment">//添加这两行</span></span><br><span class="line">apply plugin: <span class="string">'com.github.dcendents.android-maven'</span></span><br><span class="line">apply plugin: <span class="string">'com.jfrog.bintray'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">25</span></span><br><span class="line">    buildToolsVersion <span class="string">"25.0.0"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">25</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">dependencies </span>&#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    <span class="title">androidTestCompile</span><span class="params">(<span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span>, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        exclude group: <span class="string">'com.android.support'</span>, <span class="keyword">module</span>: <span class="string">'support-annotations'</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span></span><br><span class="line"><span class="function">    compile 'com.android.support:appcompat-v7:25.1.0'</span></span><br><span class="line"><span class="function">    testCompile 'junit:junit:4.12'</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//项目主页</span></span></span><br><span class="line"><span class="function">def siteUrl </span>= <span class="string">'https://github.com/backkomyoung/CircleView'</span></span><br><span class="line"><span class="comment">//项目的git地址</span></span><br><span class="line">def gitUrl = <span class="string">'https://github.com/backkomyoung/CircleView.git'</span></span><br><span class="line"><span class="comment">//发布到JCenter上的项目名字</span></span><br><span class="line">def libName = <span class="string">"CircleView"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发布到组织名称名字，必须填写</span></span><br><span class="line">group = <span class="string">"me.songning.CircleView"</span></span><br><span class="line"><span class="comment">// 版本号，下次更新是只需要更改版本号即可</span></span><br><span class="line">version = <span class="string">"1.0.0"</span></span><br><span class="line"><span class="comment">//上面配置后上传至JCenter后的编译路径是这样的： compile 'me.songning.CircleView:library:1.0.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成源文件</span></span><br><span class="line"><span class="function">task <span class="title">sourcesJar</span><span class="params">(type: Jar)</span> </span>&#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier = <span class="string">'sources'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成Javadoc文档</span></span><br><span class="line"><span class="function">task <span class="title">javadoc</span><span class="params">(type: Javadoc)</span> </span>&#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文档打包成jar</span></span><br><span class="line"><span class="function">task <span class="title">javadocJar</span><span class="params">(type: Jar, dependsOn: javadoc)</span> </span>&#123;</span><br><span class="line">    classifier = <span class="string">'javadoc'</span></span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝javadoc文件</span></span><br><span class="line"><span class="function">task <span class="title">copyDoc</span><span class="params">(type: Copy)</span> </span>&#123;</span><br><span class="line">    from <span class="string">"$&#123;buildDir&#125;/docs/"</span></span><br><span class="line">    into <span class="string">"docs"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传到JCenter所需要的源码文件</span></span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置maven库，生成POM.xml文件</span></span><br><span class="line">install &#123;</span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        <span class="comment">// This generates POM.xml with proper parameters</span></span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging <span class="string">'aar'</span></span><br><span class="line">                <span class="comment">//项目描述，随意填</span></span><br><span class="line">                name <span class="string">'A colorful circle view with text.'</span></span><br><span class="line">                url siteUrl</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        <span class="comment">//开源协议</span></span><br><span class="line">                        name <span class="string">'The Apache Software License, Version 2.0'</span></span><br><span class="line">                        url <span class="string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        <span class="comment">//开发者的个人信息</span></span><br><span class="line">                        id <span class="string">'backkomyoung'</span></span><br><span class="line">                        name <span class="string">'SongNing'</span></span><br><span class="line">                        email <span class="string">'backkomyoung@gmail.com'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传到JCenter</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties()</span><br><span class="line">properties.load(project.rootProject.file(<span class="string">'local.properties'</span>).newDataInputStream())</span><br><span class="line"></span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(<span class="string">"bintray.user"</span>)    <span class="comment">//读取 local.properties 文件里面的 bintray.user</span></span><br><span class="line">    key = properties.getProperty(<span class="string">"bintray.apikey"</span>)   <span class="comment">//读取 local.properties 文件里面的 bintray.apikey</span></span><br><span class="line">    configurations = [<span class="string">'archives'</span>]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        <span class="comment">//这里的repo值必须要和你创建Maven仓库的时候的名字一样</span></span><br><span class="line">        repo = <span class="string">"maven"</span></span><br><span class="line">        <span class="comment">//发布到JCenter上的项目名字</span></span><br><span class="line">        name = libName</span><br><span class="line">        <span class="comment">//项目描述</span></span><br><span class="line">        desc = <span class="string">'A colorful circle view with text.'</span></span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [<span class="string">"Apache-2.0"</span>]</span><br><span class="line">        publish = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">javadoc &#123;</span><br><span class="line">    options&#123;</span><br><span class="line">        <span class="comment">//如果你的项目里面有中文注释的话，必须将格式设置为UTF-8，不然会出现乱码</span></span><br><span class="line">        encoding <span class="string">"UTF-8"</span></span><br><span class="line">        charSet <span class="string">'UTF-8'</span></span><br><span class="line">        author <span class="keyword">true</span></span><br><span class="line">        version <span class="keyword">true</span></span><br><span class="line">        links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此外，还要将user和key写到local.properties文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdk.dir=E\:\\Android\\Sdk</span><br><span class="line"><span class="comment">//uer和key</span></span><br><span class="line">bintray.user=username</span><br><span class="line">bintray.apikey=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>user即为你的账号：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_user.png" alt="user"></p><p>key的话点击修改信息：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_edit.png" alt="edit"></p><p>选择左边的“API key”，然后复制key：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_key.png" alt="key"></p><p>把user和key填到上面的local.properties文件中就ok啦。准备工作到这里算是完成了。</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>打开Android Studio底部工具栏的Terminal窗口，输入命令：</p><blockquote><p>gradlew install</p></blockquote><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_loading.png" alt="build"></p><p>漫长的等待…可能是我的网络问题，吃了个饭回来才弄好。</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_build_succeed.png" alt="succeed"></p><p>显示“BUILD SUCCESSFUL”即表示成功。</p><p>到这里已经成功一半了，只差上传到Bintray了。然后我们接着在Terminal窗口输入命令：</p><blockquote><p>gradlew bintrayUpload</p></blockquote><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_bintrayUpload.png" alt="bintrayUpload"></p><p>这个很快就好~</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_upload.png" alt="upload"></p><p>同样，显示“BUILD SUCCESSFUL”即表示成功。</p><h2 id="发布到JCenter"><a href="#发布到JCenter" class="headerlink" title="发布到JCenter"></a>发布到JCenter</h2><p>这时候打开我们创建的maven仓库，就会在里面发现已经成功将项目上传到仓库里。</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_maven.png" alt="maven"></p><p>点击我们的项目名，进入详情：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_jcenter.png" alt="jcenter"></p><p>点击“Add to JCenter”后：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_send.png" alt="send"></p><p>直接点Send就行了。因为时差的关系，接下来就是漫长的等待审核了。</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_approved.png" alt="approved"></p><p>经过几个小时，在Bintray的网站上会有提示审核通过。这时候，就可以在Android Studio上通过compile的方式使用了。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>说说我遇到的问题，就是执行上传命令的时候，显示这个错误：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_upload_fail.png" alt="fail"></p><p>提示找不到“maven”，原因是我当时还没创建Maven仓库就执行上传命令，创建后再执行一遍命令就成功了。还有就是创建的Maven仓库的名字一定要和build.gradle文件里面的repo值一致。我就遇到这一个问题。</p><p>如果你们遇到其他的问题，建议看看这篇：</p><blockquote><p><a href="http://www.jianshu.com/p/c518a10fdaed" target="_blank" rel="noopener">Android 发布项目到 JCenter 遇到的各种坑</a></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里就把整个开源库发布到JCenter的流程写完了，有什么问题可以在下面留言~</p><blockquote><p>参考文章<br><a href="http://blog.csdn.net/mchaoliu/article/details/51984486" target="_blank" rel="noopener">android 将开源项目发布到JCenter及问题总结</a><br><a href="http://blog.csdn.net/yyh352091626/article/details/51901562" target="_blank" rel="noopener">利用Gradle发布项目到JCenter、Maven</a><br><a href="https://gold.xitu.io/post/5858cc37570c35006916b718" target="_blank" rel="noopener">新版Bintray-极简上传Library到JCenter</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ofp4swv4i.bkt.clouddn.com/upload_to_jcenter_register1.png&quot; alt=&quot;register1&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你写好了一个开源库，是否也想像其他的开源库一样在Android Studio中一句compile就可以引用。比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compile ‘com.android.support:appcompat-v7:25.1.0’
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/source/categories/Android/"/>
    
    
      <category term="JCenter" scheme="http://songning.me/source/tags/JCenter/"/>
    
  </entry>
  
  <entry>
    <title>自定义View，从画个圆写个字开始</title>
    <link href="http://songning.me/2016/12/21/circle-view/"/>
    <id>http://songning.me/2016/12/21/circle-view/</id>
    <published>2016-12-21T12:17:18.000Z</published>
    <updated>2017-04-02T03:34:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>老早以前就开始看关于自定义View的文章了，这两天实践了一下以前看的有关自定义View的知识，画了个控件。这个控件虽然看起来简单，但自定义View的基本用法都用到了。麻雀虽小，五脏俱全，所以还是记录一下过程。<a id="more"></a></p><p>关于自定义View的文章，我在这墙裂推荐一下GcsSloop写的<a href="http://www.gcssloop.com/customview/CustomViewIndex" target="_blank" rel="noopener">安卓自定义View教程。</a>这是目前我认为写得比较好的关于自定义View的文章，而且很完整也很详细，通俗易懂。</p><p>那么，回归主题，就从画个不简单的圆开始吧。先看效果图，我知道没有图你们是不会往下看的。</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/circle_view_demo_gif.gif" alt="gif"><br><img src="http://ofp4swv4i.bkt.clouddn.com/circle_view_in_rv.png" alt="in_rv"></p><p>gif图的效果有点卡顿，真机上是很流畅的。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>拿到一个效果图，先看看要怎么画，思考清楚再去干活有时候会事半功倍（其实刚开始我只是打算画个圆，画着画着就越来越多了…）。我们这效果很简单，我们现在的需求只是要画个圆，然后再在上面写个字。</p><h3 id="画个圆"><a href="#画个圆" class="headerlink" title="画个圆"></a>画个圆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = getPaddingLeft();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingRight = getPaddingRight();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingTop = getPaddingTop();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingBottom = getPaddingBottom();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width = getWidth() - paddingLeft - paddingRight;</span><br><span class="line">    <span class="keyword">int</span> height = getHeight() - paddingTop - paddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> centerX = paddingLeft + width / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> centerY = paddingTop + height / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> radius = Math.min(width, height) / <span class="number">2</span>;</span><br><span class="line">    canvas.drawCircle(centerX, centerY, radius, mCirclePaint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画圆的代码很简单，因为是继承自View，所以需要先在onDrow方法中先进行处理padding，不然padding会失效。拿到我们的View的实际的宽高后，再去获取View的中心点，用来当作圆心位置。因为我这里的画布的坐标原点在屏幕左上角，所以获取中心点的时候要加上paddingLeft和paddingTop的距离。centerX和centerY组成的点是我们布局的中心点。拿到中心点后，再根据长宽中的最小值的一半当作半径，然后就可以进行绘制圆了。So easy!</p><h3 id="写个字"><a href="#写个字" class="headerlink" title="写个字"></a>写个字</h3><p>drawText我们用到的是四个参数的方法，这里有个要注意的地方就是第二个参数和第三个参数并不是文字的中心位置，分别是文字左边的X值和文字底部的Y值。看下源码就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Draw the text, with origin at (x,y), using the specified paint. The</span></span><br><span class="line"><span class="comment"> * origin is interpreted based on the Align setting in the paint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text  The text to be drawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x     The x-coordinate of the origin of the text being drawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y     The y-coordinate of the baseline of the text being drawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paint The paint used for the text (e.g. color, size, style)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(@NonNull String text, <span class="keyword">float</span> x, <span class="keyword">float</span> y, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">    native_drawText(mNativeCanvasWrapper, text, <span class="number">0</span>, text.length(), x, y, paint.mBidiFlags,</span><br><span class="line">            paint.getNativeInstance(), paint.mNativeTypeface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个baseline又是什么？baseline就是文字底部的Y值。看看下面这张图你就明白了：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/ciecle_view_text.png" alt="text"></p><p>想要把文字放在圆的中心位置，先要找到baseline和文字的左边X值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawVerticalText</span><span class="params">(Canvas canvas, <span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, String text)</span> </span>&#123;</span><br><span class="line">    Paint.FontMetrics fontMetrics = mVerticalTextPaint.getFontMetrics();</span><br><span class="line">    <span class="keyword">float</span> baseLine = -(fontMetrics.ascent + fontMetrics.descent) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> textWidth = mVerticalTextPaint.measureText(text);</span><br><span class="line">    <span class="keyword">float</span> startX = centerX - textWidth / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> endY = centerY + baseLine;</span><br><span class="line">    canvas.drawText(text, startX, endY, mVerticalTextPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上有很多关于drawText的文章，不过多数是用一个Rect包裹着再画，我这里是直接画。画字在这里我封装成了一个方法，从画笔中拿到FontMetrics对象，用来获取文字的属性，包括Ascent值和Descent值等。然后计算baseline，用Paint的measureText方法获取文字的长度。最后根据中心点偏移一下把文字放到中间，ok。看一下效果：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/circle_view_one.png" alt="one"></p><h3 id="文字竖排"><a href="#文字竖排" class="headerlink" title="文字竖排"></a>文字竖排</h3><p>这时，又有个需求，我想要文字竖排显示怎么弄？第一反应想到的是drawText是不是应该有个可以控制方向的方法或参数？然而，并没有这么容易。drawText并不能竖排画文字，那么drawTextOnPath方法是不是可以呢？在圆的竖直方向建一条路径，但是结果并不是很理想，图我就不放了。最后想到的是用StaticLayout这个类，通过换行来实现竖排，其实TextView源码中也用到了这个来换行。来看主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mHorizontalTextPaint = <span class="keyword">new</span> TextPaint(mVerticalTextPaint);</span><br><span class="line">   mStaticLayout = <span class="keyword">new</span> StaticLayout(mText, mHorizontalTextPaint, <span class="number">1</span>, Layout.Alignment.ALIGN_CENTER, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">false</span>);</span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawHorizontalText</span><span class="params">(Canvas canvas, <span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY)</span> </span>&#123;</span><br><span class="line">       canvas.translate(centerX, centerY - mStaticLayout.getHeight() / <span class="number">2</span>);</span><br><span class="line">       mStaticLayout.draw(canvas);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>StaticLayout的构造方法第二个参数需要传个TextPaint进去，TextPaint是继承自Paint，所以可以直接传个我们上面画水平方向文字的时候的Paint对象进去就行了，就不用重新设置颜色字体大小等属性。关于StaticLayout的构造方法的参数是什么作用我这就不详细说了，我们主要看第三个参数。这个参数代表超过多少个字符就换行，这里我们传个1代表一个就换行。然后把画布X轴移动到圆心坐标，文字的高度的一半为圆心Y轴的值。这样，我们就实现了文字竖排：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/circle_view_two.png" alt="two"></p><h3 id="文字任意角度"><a href="#文字任意角度" class="headerlink" title="文字任意角度"></a>文字任意角度</h3><p>继续加需求，要求文字45°斜着显示该怎么弄？这个简单，把画布坐标旋转不就可以了吗~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.rotate(mAngle, centerX, centerY);</span><br><span class="line">drawText(canvas, centerX, centerY);</span><br></pre></td></tr></table></figure><p>调用画布的rotate方法就可以了，就一行代码。但是这里要注意的是在drawText前面旋转画布后再drawText，一定要在drawText前面旋转画布！不然是没效果的，我在这就跳进坑里了T.T 在drawText后才旋转画布，一直没反应。还以为是哪里出错了。</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/circle_view_three.png" alt="three"></p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>静态的文字头像有点单调了，那就加个动画吧。好，说加就加，加个旋转的吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startRotateAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAnimator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        initRotateAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mAnimator.isRunning()) &#123;</span><br><span class="line">        mAnimator.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRotateAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRotateOrientation == ROTATE_CLOCKWISE) &#123;</span><br><span class="line">        mRotateValues = <span class="number">360f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mRotateOrientation == ROTATE_ANTICLOCKWISE) &#123;</span><br><span class="line">        mRotateValues = -<span class="number">360f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimator = ValueAnimator.ofFloat(<span class="number">0f</span>, mRotateValues);</span><br><span class="line">    mAnimator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">    mAnimator.setDuration(mSpeed);</span><br><span class="line">    mAnimator.addUpdateListener(<span class="keyword">this</span>);</span><br><span class="line">    mAnimator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    mAnimator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">    mAngle = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopRotateAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAnimator != <span class="keyword">null</span> &amp;&amp; mAnimator.isRunning()) &#123;</span><br><span class="line">        mAnimator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于旋转动画的主要就这四个方法。原理是用属性动画ValueAnimator动态线性均匀改变一个0到360浮点值，在AnimatorUpdateListener的onAnimationUpdate方法获取范围值，mAngle为上面任意角度文字的值，动态改变这个值，不断重绘界面，就可以实现文字的旋转动画了。至于上面的360f和-360f是用来控制方向的，顺时针或者逆时针旋转。通过持续时间setDuration来控制速度。转起来：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/circle_view_four.gif" alt="four"></p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>看到FloatingActionButton自带的show和hide的动画，这里我也仿照着弄了个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isShow) &#123;</span><br><span class="line">        scaleAnimation(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">300</span>);</span><br><span class="line">        isShow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShow) &#123;</span><br><span class="line">        scaleAnimation(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">300</span>);</span><br><span class="line">        isShow = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scaleAnimation</span><span class="params">(<span class="keyword">float</span> start, <span class="keyword">float</span> end, <span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">    ObjectAnimator animatorX = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="string">"scaleX"</span>, start, end);</span><br><span class="line">    ObjectAnimator animatorY = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="string">"scaleY"</span>, start, end);</span><br><span class="line">    AnimatorSet animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">    animatorSet.setDuration(duration);</span><br><span class="line">    animatorSet.playTogether(animatorX, animatorY);</span><br><span class="line">    animatorSet.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是通过属性动画ObjectAnimator，去缩放X轴方向“scaleX”，和Y轴方向“scaleY”。把两个动画放到一个动画集AnimatorSet里面同时执行，从0f到1f是显示，1f到0f是隐藏。</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/circle_view_five.gif" alt="five"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，这个文字头像控就控件就写完了。其实没什么很难的地方，只是把自定义View的基本流程写了一遍。对于学习自定义View，光看是不行的，一定要实践，动手后发现也没想象中的那么难。</p><p>同时，我将这个CircleView封装了一下发布到了JCenter，免得重复造轮子。</p><blockquote><p>项目地址：<a href="https://github.com/backkomyoung/CircleView" target="_blank" rel="noopener">https://github.com/backkomyoung/CircleView</a></p></blockquote><p>喜欢就点个Star吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;老早以前就开始看关于自定义View的文章了，这两天实践了一下以前看的有关自定义View的知识，画了个控件。这个控件虽然看起来简单，但自定义View的基本用法都用到了。麻雀虽小，五脏俱全，所以还是记录一下过程。
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/source/categories/Android/"/>
    
    
      <category term="自定义View" scheme="http://songning.me/source/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>优雅的使用MVP+RxJava+Retrofit框架</title>
    <link href="http://songning.me/2016/11/09/mvp-rxjava-retrofit/"/>
    <id>http://songning.me/2016/11/09/mvp-rxjava-retrofit/</id>
    <published>2016-11-09T08:34:09.000Z</published>
    <updated>2017-04-02T03:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ofp4swv4i.bkt.clouddn.com/mvp-rxjava-retrofit.png" alt="mvp"></p><p>前面我已经写过一篇关于Google的RxJava版MVP解读的文章，本篇就是我在此基础上进行了修改和封装，稍微变化一下，见上图。目的是让这个框架更加实用，同时简化操作，少写代码。<a id="more"></a>果然程序员都是喜欢偷懒的- -</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，阅读本篇文章前，建议你先去了解一下MVP这个设计模式。当然，也可以先看看我前面的文章^_^ <a href="http://songning.me/2016/11/03/google-rxjava-mvp/">传送门</a></p><p>另外，还用到了<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>、<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a>、<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">Okhttp</a>。如果你已经了解了他们的基本用法，请直接忽略这段，接着往下看~</p><p>不想看长长的文章的，可以直接看代码。代码地址已经上传到Github，<a href="https://github.com/backkomyoung/MVP" target="_blank" rel="noopener">传送门。</a></p><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>按照惯例，先看看工程的主要结构：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/mvp-rxjava-retrofit-package.png" alt="project"></p><p>简单说一下几个主要包下的功能。首先是api包，这是存放对Retrofit进行包装的类。Base包当然是放各种Base类啦~ mvp包是将契约类Contract、Model的实现类和Presenter的实现类放一起，方便管理。其实你也可以按功能分包，个人喜好吧。ui包放一些界面的类，如Activity和Fragment。</p><p>下面正式开始~</p><h2 id="契约类"><a href="#契约类" class="headerlink" title="契约类"></a>契约类</h2><p>同样也是从Contract契约类开始说起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSucceed</span><span class="params">(Gank data)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String err)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hideDialog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Model</span> <span class="keyword">extends</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">        <span class="function">Observable&lt;Gank&gt; <span class="title">getGank</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>&lt;<span class="title">View</span>, <span class="title">Model</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getGank</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，整体上和Google的Demo差不多，都是把View和Presenter放到Contract类里面统一管理，我这里多加了个Model接口，我不推荐在Presenter进行Model操作，本来很优雅的一件事，在Presenter进行Model操作的话，感觉就差了很多，要做一个优雅的程序员。不同的地方是Model和View接口继承了BaseModel接口和BaseView接口，Presenter变成了一个抽象类，继承于BasePresenter抽象类，传入两个泛型View、Model。为啥呢？我们接着看Base包下的三个Base类。</p><h2 id="Base类"><a href="#Base类" class="headerlink" title="Base类"></a>Base类</h2><p>BaseModel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BasePresenter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">BaseView</span>, <span class="title">M</span> <span class="keyword">extends</span> <span class="title">BaseModel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V mView;</span><br><span class="line">    <span class="keyword">protected</span> M mModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CompositeSubscription mCompositeSubscription;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCompositeSubscription == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCompositeSubscription = <span class="keyword">new</span> CompositeSubscription();</span><br><span class="line">        &#125;</span><br><span class="line">        mCompositeSubscription.add(subscription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unSubscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mCompositeSubscription != <span class="keyword">null</span> &amp;&amp; mCompositeSubscription.hasSubscriptions()) &#123;</span><br><span class="line">            mCompositeSubscription.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseModel和BaseView接口里面是空的，在这里我只是为了在BasePresenter中提供一个约束。当然，如果你有其它全局的需求，可以在里面添加一些方法。重点是BasePresenter这个抽象类，传入一个View和Model，并将其用protected关键字修饰，这样，在它的子类中就可以直接对其赋值和使用了。加入CompositeSubscription变量，是为了对RxJava进行管理。unSubscribe方法对View进行null赋值和清除Rx的Subscription（订阅），防止内存泄漏。</p><h2 id="Presnter桥梁"><a href="#Presnter桥梁" class="headerlink" title="Presnter桥梁"></a>Presnter桥梁</h2><p>接下来看看这个很重要的类，作为连接Model和View的桥梁，这里又是怎么做的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> <span class="keyword">extends</span> <span class="title">MainContract</span>.<span class="title">Presenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenter</span><span class="params">(MainContract.View view)</span> </span>&#123;</span><br><span class="line">        mView = view;</span><br><span class="line">        mModel = <span class="keyword">new</span> MainModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getGank</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Subscription subscribe = mModel.getGank()</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;Gank&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        mView.showDialog();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        mView.hideDialog();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        mView.onFail(e.getMessage());</span><br><span class="line">                        onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Gank gank)</span> </span>&#123;</span><br><span class="line">                        mView.onSucceed(gank);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        addSubscribe(subscribe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法传进一个View，并且new了一个Model对象，直接赋值给父类中的View和Model。然后下面复写的方法中调用Model中的方法，再将结果通过View中的方法传出去，这是很原始的MVP方式。最后addSubscribe添加到订阅队列中。</p><h2 id="Model处理数据"><a href="#Model处理数据" class="headerlink" title="Model处理数据"></a>Model处理数据</h2><p>Model分出来，而不在Presenter处理，其实也是为了简洁，当你要处理很多数据的时候，Presenter就会变得很乱了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainModel</span> <span class="keyword">implements</span> <span class="title">MainContract</span>.<span class="title">Model</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;Gank&gt; <span class="title">getGank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ApiEngine.getInstance().getApiService()</span><br><span class="line">                .getGank(<span class="string">"1"</span>)</span><br><span class="line">                .compose(RxSchedulers.&lt;Gank&gt;switchThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里很简单，就获取ApiService对象，然后调用API。最后compose传进我自己定义的线程切换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable.<span class="function">Transformer&lt;T, T&gt; <span class="title">switchThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Observable&lt;T&gt; tObservable)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tObservable</span><br><span class="line">                        .subscribeOn(Schedulers.io())</span><br><span class="line">                        .unsubscribeOn(Schedulers.io())</span><br><span class="line">                        .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将网络请求的IO线程切换回Android的UI主线程，才能继续进行在Presenter中的操作。</p><h2 id="BaseActivity中的封装"><a href="#BaseActivity中的封装" class="headerlink" title="BaseActivity中的封装"></a>BaseActivity中的封装</h2><p>在前面我们可以看到BasePresenter中有两个方法，一个是添加订阅addSubscribe，另一个是unSubscribe解除订阅。我们只看到了在Presenter中使用了addSubscribe，而没有看到unSubscribe在哪使用了。因为要防止内存泄漏，所以当然要在和生命周期相关的地方进行释放资源，这个地方只有我们所说的View了，也就是Activity和Fragment中。我们先开看一下相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>&gt; <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> P mPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (onCreatePresenter() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPresenter = onCreatePresenter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (mPresenter!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            mPresenter.unSubscribe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> P <span class="title">onCreatePresenter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过泛型确定一个Presenter的类型，然后使用抽象方法onCreatePresenter对其进行赋值，最后在onDestroy方法中进行资源的释放。继承这个BaseActivity类的Activity，就不用每次都在onDestroy进行同样的操作啦~达到简洁的目的。同理，Fragment中也是同样的，只是在生命周期的onResume和onPause中分别进行Presenter的赋值和资源的释放。这里我就不贴代码，可以上我的<a href="https://github.com/backkomyoung/MVP/blob/master/app/src/main/java/me/songning/mvp/base/BaseFragment.java" target="_blank" rel="noopener">Github</a>看。</p><h2 id="Retrofit引擎封装"><a href="#Retrofit引擎封装" class="headerlink" title="Retrofit引擎封装"></a>Retrofit引擎封装</h2><p>说到这了，就顺便说一下Retrofit吧。上面的MainModel类中用到了ApiEngine类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiEngine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ApiEngine apiEngine;</span><br><span class="line">    <span class="keyword">private</span> Retrofit retrofit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ApiEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//日志拦截器</span></span><br><span class="line">        HttpLoggingInterceptor loggingInterceptor = <span class="keyword">new</span> HttpLoggingInterceptor();</span><br><span class="line">        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓存</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line">        File cacheFile = <span class="keyword">new</span> File(App.getContext().getCacheDir(), <span class="string">"OkHttpCache"</span>);</span><br><span class="line">        Cache cache = <span class="keyword">new</span> Cache(cacheFile, size);</span><br><span class="line"></span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .connectTimeout(<span class="number">12</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">12</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">12</span>, TimeUnit.SECONDS)</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> NetworkInterceptor())</span><br><span class="line">                .addInterceptor(loggingInterceptor)</span><br><span class="line">                .cache(cache)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(ApiService.BASE_URL)</span><br><span class="line">                .client(client)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiEngine <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apiEngine == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ApiEngine.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (apiEngine == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    apiEngine = <span class="keyword">new</span> ApiEngine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apiEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiService <span class="title">getApiService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.create(ApiService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了单例模式，在构造方法中只初始化一次Retrofit和Okhttp。双重锁的方式获取单例，然后再根据需要获取ApiService，如果你有很多个不同源的API，那就可以创建多个getXXXXApiService。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后，来看看Demo运行效果吧：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/mvp-rxjava-retrofit-gif.gif" alt="demo_gif"></p><p>Demo数据源来自<a href="http://gank.io/api" target="_blank" rel="noopener">Gank.io</a></p><p>其实还有一个问题，就是关于错误类型的统一处理。刚开始的时候我是打算添加进去的，但是后来想想，每个项目的API都有不同的需求，有不同的错误，所以，还是留给需要的时候再封装一层错误处理吧。如果要统一处理错误，自定义一个Subscriber，在里面的onError方法处理即可。</p><p>至此，对于MVP的改良封装到此结束啦~ 如有什么问题，欢迎评论交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ofp4swv4i.bkt.clouddn.com/mvp-rxjava-retrofit.png&quot; alt=&quot;mvp&quot;&gt;&lt;/p&gt;
&lt;p&gt;前面我已经写过一篇关于Google的RxJava版MVP解读的文章，本篇就是我在此基础上进行了修改和封装，稍微变化一下，见上图。目的是让这个框架更加实用，同时简化操作，少写代码。
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/source/categories/Android/"/>
    
    
      <category term="MVP" scheme="http://songning.me/source/tags/MVP/"/>
    
      <category term="RxJava" scheme="http://songning.me/source/tags/RxJava/"/>
    
      <category term="Retrofit" scheme="http://songning.me/source/tags/Retrofit/"/>
    
      <category term="框架" scheme="http://songning.me/source/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Google官方MVP框架源码解读</title>
    <link href="http://songning.me/2016/11/03/google-rxjava-mvp/"/>
    <id>http://songning.me/2016/11/03/google-rxjava-mvp/</id>
    <published>2016-11-03T07:54:41.000Z</published>
    <updated>2016-11-10T08:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ofp4swv4i.bkt.clouddn.com/google-rxjava-mvp.png" alt="mvp"></p><p>最近在看关于MVP框架的封装，于是网上搜了一下，发现了<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">谷歌官方的MVP Demo</a>，发现还是Google的看着顺眼，上图为Demo的框架图。于是就对其分析了一下。Google的MVP版本很多，不过<a id="more"></a>思想都一样，所以就拿当前较火的RxJava那个MVP版本进行分析。</p><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>首先我们来看一下整个工程里面的包的结构：</p><p><img src="http://ofp4swv4i.bkt.clouddn.com/google-rxjava-mvp-main.png" alt="工程结构"></p><p>整个工程结构不难，除了data层是处理数据外，其他都是按功能分模块。</p><h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><p>我们挑其中的一个addedittask模块来看，可以看到里面有个叫AddEditTaskContract的类，这个类是干嘛用的呢？ 这就是和普通的MVP结构不同的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddEditTaskContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showEmptyTaskError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTasksList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">saveTask</span><span class="params">(String title, String description)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">populateTask</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Contract字面意思是契约，这个契约类的作用是把View层和Presenter层的接口包装起来，方便管理，同时也减少了接口文件的数量。BaseView传了个Presenter的泛型进去，我们接下来看看BaseView和BasePresenter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseView中只有一个方法setPresenter，这个方法的作用是获取Presenter对象，方便在View层使用（如在Activity和Fragment中）。看见BasePresenter中的两个方法，是不是就想到了RxJava里的订阅和解除订阅？没错，在这里还真的是这个意思。</p><p>下面，就开始介绍它们的实现类了~ </p><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><h3 id="Presenter实现类"><a href="#Presenter实现类" class="headerlink" title="Presenter实现类"></a>Presenter实现类</h3><p>首先是实现了AddEditTaskContract.Presenter接口的AddEditTaskPresenter类，先看参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AddEditTaskContract.View mAddTaskView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BaseSchedulerProvider mSchedulerProvider;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String mTaskId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> CompositeSubscription mSubscriptions;</span><br></pre></td></tr></table></figure><p>其中TasksDataSource是数据源，AddEditTaskContract.View是View对象，BaseSchedulerProvider是订阅提供者（用于线程切换），CompositeSubscription可以理解为RxJava的订阅管理者，在适当的时候解除订阅防止内存泄漏。</p><p>然后看构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AddEditTaskPresenter</span><span class="params">(@Nullable String taskId,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @NonNull TasksDataSource tasksRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @NonNull AddEditTaskContract.View addTaskView,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @NonNull BaseSchedulerProvider schedulerProvider)</span> </span>&#123;</span><br><span class="line">    mTaskId = taskId;</span><br><span class="line">    mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null!"</span>);</span><br><span class="line">    mAddTaskView = checkNotNull(addTaskView, <span class="string">"addTaskView cannot be null!"</span>);</span><br><span class="line">    mSchedulerProvider = checkNotNull(schedulerProvider, <span class="string">"schedulerProvider cannot be null!"</span>);</span><br><span class="line"></span><br><span class="line">    mSubscriptions = <span class="keyword">new</span> CompositeSubscription();</span><br><span class="line">    mAddTaskView.setPresenter(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造方法传进来了三个主要的参数，同时初始化了CompositeSubscription。注意看，上面BaseView中提到的setPresenter方法在这里用到了，就是获取当前对象，也就是Presenter对象。至于构造方法中传进来的对象怎么来的，我们等下在View层会详细讲。</p><p>剩下的就是接口实现的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTaskId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        populateTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSubscriptions.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 省略部分代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTaskId == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"populateTask() was called but task is new."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Subscription subscription = mTasksRepository</span><br><span class="line">            .getTask(mTaskId)</span><br><span class="line">            .subscribeOn(mSchedulerProvider.computation())</span><br><span class="line">            .observeOn(mSchedulerProvider.ui())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;Task&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (mAddTaskView.isActive()) &#123;</span><br><span class="line">                        mAddTaskView.showEmptyTaskError();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (mAddTaskView.isActive()) &#123;</span><br><span class="line">                        mAddTaskView.setTitle(task.getTitle());</span><br><span class="line">                        mAddTaskView.setDescription(task.getDescription());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    mSubscriptions.add(subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要看subscribe、unsubscribe和populateTask方法。在subscribe方法中进行初始化数据，调用了populateTask方法添加订阅和获取数据。unsubscribe方法中进行解除订阅。在populateTask方法中，返回数据的地方调用了View的接口，将数据传给View层。至此，整个Presenter算是讲完啦。我们接下来看到View层，也就是Activity或者Fragment。</p><h3 id="View实现类"><a href="#View实现类" class="headerlink" title="View实现类"></a>View实现类</h3><p>先看代码，下面的代码我们只看重要的部分，所以省略了很多，想看完整的可以下载<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-rxjava/" target="_blank" rel="noopener">Google官方完整的代码</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AddEditTaskContract</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AddEditTaskContract.Presenter mPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mPresenter.subscribe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        mPresenter.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(@NonNull AddEditTaskContract.Presenter presenter)</span> </span>&#123;</span><br><span class="line">        mPresenter = checkNotNull(presenter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEmptyTaskError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Snackbar.make(mTitle, getString(R.string.empty_task_message), Snackbar.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTasksList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getActivity().setResult(Activity.RESULT_OK);</span><br><span class="line">        getActivity().finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        mTitle.setText(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        mDescription.setText(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAdded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，AddEditTaskFragment实现了AddEditTaskContract.View接口。然后在onResume和onPause这两个关系生命周期的地方进行了和Presenter的绑定（防止内存泄漏），在setPresenter方法中获取Presenter实例。再看下面一堆的View接口中定义的方法，就是得到数据后用来进行界面操作了啦~</p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>上面说到AddEditTaskPresenter的构造方法中的参数怎么来的，因为是RxJava的MVP版本，就顺带说一下吧。因为整个工程是多Activity+多Fragment的结构，其实是在Activity中创建了Fragment对象，然后添加到布局中的。我们看一下AddEditTaskActivity的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_ADD_TASK = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.addtask_act);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">        AddEditTaskFragment addEditTaskFragment =</span><br><span class="line">                (AddEditTaskFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line"></span><br><span class="line">        String taskId = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (addEditTaskFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addEditTaskFragment = AddEditTaskFragment.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getIntent().hasExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID)) &#123;</span><br><span class="line">                taskId = getIntent().getStringExtra(</span><br><span class="line">                        AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID);</span><br><span class="line">                actionBar.setTitle(R.string.edit_task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                actionBar.setTitle(R.string.add_task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ActivityUtils.addFragmentToActivity(getSupportFragmentManager(),</span><br><span class="line">                    addEditTaskFragment, R.id.contentFrame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the presenter</span></span><br><span class="line">        <span class="keyword">new</span> AddEditTaskPresenter(</span><br><span class="line">                taskId,</span><br><span class="line">                Injection.provideTasksRepository(getApplicationContext()),</span><br><span class="line">                addEditTaskFragment,</span><br><span class="line">                Injection.provideSchedulerProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了AddEditTaskFragment对象，然后添加到布局中。最后new了一个AddEditTaskPresenter，这才是重点。到这里，不禁有一个问题，AddEditTaskPresenter构造方法的第二个和第四个参数是哪来的？我们再看Injection类就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Injection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TasksRepository <span class="title">provideTasksRepository</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">        checkNotNull(context);</span><br><span class="line">        <span class="keyword">return</span> TasksRepository.getInstance(FakeTasksRemoteDataSource.getInstance(),</span><br><span class="line">                TasksLocalDataSource.getInstance(context, provideSchedulerProvider()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseSchedulerProvider <span class="title">provideSchedulerProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SchedulerProvider.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章都快看完了，都说MVP，Model层在哪里呢？看上面代码中的provideTasksRepository方法，其实这就相当于Model层，获取到数据后传给Presenter，只不过用了一个数据源的名字，功能都一样。provideSchedulerProvider方法是获取一个RxJava的线程调度器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerProvider</span> <span class="keyword">implements</span> <span class="title">BaseSchedulerProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SchedulerProvider INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent direct instantiation.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SchedulerProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SchedulerProvider <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> SchedulerProvider();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">computation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Schedulers.computation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Schedulers.io();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">ui</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AndroidSchedulers.mainThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类用了懒汉式获取单例（看源码还是有收获的^_^），实现了BaseSchedulerProvider接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseSchedulerProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Scheduler <span class="title">computation</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Scheduler <span class="title">io</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Scheduler <span class="title">ui</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共三个线程，计算线程、IO线程、UI线程，完成了对RxJava线程管理的封装使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次解读，收益良多。目前来说，MVP确实是个好框架，而且RxJava便捷的线程切换对于在Model层中进行IO操作和Presenter层的UI操作的支持，两者简直是天生一对。</p><p>对于Google官方MVP框架的源码解读到这就结束啦，下一篇将对MVP进行封装一下，让这个框架更加实用，同时简化操作，少写代码。敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ofp4swv4i.bkt.clouddn.com/google-rxjava-mvp.png&quot; alt=&quot;mvp&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在看关于MVP框架的封装，于是网上搜了一下，发现了&lt;a href=&quot;https://github.com/googlesamples/android-architecture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谷歌官方的MVP Demo&lt;/a&gt;，发现还是Google的看着顺眼，上图为Demo的框架图。于是就对其分析了一下。Google的MVP版本很多，不过
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/source/categories/Android/"/>
    
    
      <category term="MVP" scheme="http://songning.me/source/tags/MVP/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式 - 单例模式</title>
    <link href="http://songning.me/2016/10/29/singleton-pattern/"/>
    <id>http://songning.me/2016/10/29/singleton-pattern/</id>
    <published>2016-10-29T09:19:04.000Z</published>
    <updated>2016-10-30T07:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是一种很常见的设计模式，我们在各种第三方库的源码中经常可以看见它的身影。单例的本质是控制实例的数量，全局有且只有一个对象，并且能够全局访问。虽然它很“小”，但作用却很大。<a id="more"></a>例如可以节约系统内存资源，防止一些不必要的操作。 但凡做Java相关的编程工作，都应该要了解Java中的单例是怎么写的，常见的有几种写法，特点是什么。常见的有下面几种：</p><h2 id="常见写法"><a href="#常见写法" class="headerlink" title="常见写法"></a>常见写法</h2><p>这应该是最简单的写法，也叫懒汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法有一个问题就是当多个线程同时调用getInstance方法的时候，就会产生多个实例，这样线程就会变得不安全了。</p><p>既然存在多个线程同时调用这个问题，所以我们会想到synchronized关键字似乎可以解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized同步锁可以保证这个方法只能同时被一个线程占有，这样看来好像是可以防止多个线程同时调用而产生多个实例这个问题，但是也有副作用。我们的目的其实只是在第一个初始化mInstance的时候需要锁上，而后面取用mInstance的时候，根本不需要线程同步。上面的写法是每次调用getInstance获取实例的时候都会进行同步锁检查，这无疑降低了效率，同时增加了资源的消耗。</p><h2 id="双重检查锁写法"><a href="#双重检查锁写法" class="headerlink" title="双重检查锁写法"></a>双重检查锁写法</h2><p>既然上面的写法在每次getInstance的时候都检查锁，降低了效率消耗了大量资源。于是就产生了双重检查锁写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//保证了同一时间只能只能有一个对象访问此同步块        </span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要同步初始化mInstance的那部分代码，这样看起来好像可以了。但是，整个流程是这样的，首先给mInstance分配内存，然后调用构造方法进行初始化操作，最后才将mInstance对象指向分配的内存空间。要是初始化操作的时候花费了大量的时间，这里的顺序如果在此时被打断的话，那么mInstance对象将指向为完成初始化的mInstance的内存空间，这时就会报错了。这时，volatile关键字就登场了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加volatile关键字修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//保证了同一时间只能只能有一个对象访问此同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的值，相当于自动发现最新值。volatile也相当于一个微型的锁，执行的顺序就不会被打乱了，mInstance对象也不会指向未完成初始化的mInstance的内存空间，最终完成单例模式的实现。</p><p>这种方法是比较推荐用的，很多开源库都是用这种方法，我用得最多的也是这种方法。</p><h2 id="饿汉式写法"><a href="#饿汉式写法" class="headerlink" title="饿汉式写法"></a>饿汉式写法</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式特点是提前实例化，没有懒汉式中多线程问题，但不管我们是不是调用getInstance方法都会存在一个实例在内存中。这样会延长类的加载时间，不能传递参数，并且占用资源，造成浪费。</p><h2 id="静态内部类写法"><a href="#静态内部类写法" class="headerlink" title="静态内部类写法"></a>静态内部类写法</h2><p>这是在<a href="http://item.jd.com/10058902.html" target="_blank" rel="noopener">《Effective Java》</a>中推荐的一种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和饿汉式有点像，但是在类加载的时候并没有初始化，只是在调用getInstance方法的时候才会从静态内部类中加载。而且没有多线程的问题，也是一种推荐的写法。</p><h2 id="枚举写法"><a href="#枚举写法" class="headerlink" title="枚举写法"></a>枚举写法</h2><p>在<a href="http://item.jd.com/10058902.html" target="_blank" rel="noopener">《Effective Java》</a>中还看到了一种比较少见的写法，枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton.INSTANCE.doSomething();</span><br></pre></td></tr></table></figure><p>因为枚举的特性，保证了只有一个实例，而且自由序列化，线程安全。所以，也可以用枚举的方法写单例模式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们比较了几种常见的写法，最终推荐是用双重检查锁写法和静态内部类的写法。枚举虽然也可以，但是在Android开发中几乎没见过，而且Google的Android官网不建议使用enums，因为占用内存多。所以如果是Android开发，还是用双重检查锁写法或者静态内部类的写法吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是一种很常见的设计模式，我们在各种第三方库的源码中经常可以看见它的身影。单例的本质是控制实例的数量，全局有且只有一个对象，并且能够全局访问。虽然它很“小”，但作用却很大。
    
    </summary>
    
      <category term="Java" scheme="http://songning.me/source/categories/Java/"/>
    
    
      <category term="基础" scheme="http://songning.me/source/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://songning.me/source/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Activity的四种启动模式</title>
    <link href="http://songning.me/2016/10/28/activity-launch-mode/"/>
    <id>http://songning.me/2016/10/28/activity-launch-mode/</id>
    <published>2016-10-28T13:06:30.000Z</published>
    <updated>2017-04-02T03:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为要为了出去工作而准备面试了，所以有必要总结一下这一年多来学习Android的知识点，同时也能复习一下所学所得。有些虽然很基础，但有句老话叫“好记性不如烂笔头”。好了，废话不多说，就从基本的Activity启动模式开始。<a id="more"></a></p><h2 id="设置Activity的启动模式"><a href="#设置Activity的启动模式" class="headerlink" title="设置Activity的启动模式"></a>设置Activity的启动模式</h2><p>怎么设置Activity的启动模式呢？有两种方法：</p><ol><li><p>在AndroidManifest.xml中，设置launchMode属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/title_activity_second"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"standard"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在启动Activity的时候，设置setFlags：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li></ol><p>两种设置模式的方法还是有区别的，按照惯例Java代码中的优先级肯定高于xml代码中的，如果两种都存在的话，以Java代码中的为准。另外在AndroidManifest.xml中无法设置FLAG_ACTIVITY_CLEAR_TOP标识，在Java代码中无法指定singleInstance模式。</p><h2 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h2><h3 id="standard：标准模式"><a href="#standard：标准模式" class="headerlink" title="standard：标准模式"></a>standard：标准模式</h3><p>系统的默认模式，如果你没有设置启动模式的话就是这个模式。标准模式下的特点是每启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。被创建的Activity实例的生命周期正常调用，也就是onCreate、onStart、onResume都会被调用。</p><p>在这种模式下，当我们多次启动同一个Activity的时候，系统就会创建多个实例并把他们一一放到任务栈中。任务栈是一种后进先出的结构，每当我们按一下返回键的时候，就会有一个Activity出栈。另外我发现微信有很多功能都是快速点击的话会创建多个Activity，比如快速点击两下朋友圈，就会创建两个朋友圈的Activity，我不知道这是微信有意为之还是程序员疏忽了这些细节问题。</p><p>在<a href="http://item.jd.com/11760209.html" target="_blank" rel="noopener">《Android开发艺术探索》</a>提到，如果用ApplicationContext去启动一个Activity的话，会报错。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">App.getContext().startActivity(intent);</span><br></pre></td></tr></table></figure><p>我试了下果然报了这个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure><p>这是因为standard模式下的Activity会默认进入启动它的Activity所属的任务栈，但是直接用ApplicationContext去启动它的话并没有所谓的任务栈，所以报错了。解决这个问题的方法是为待启动的Activity一个标记位FLAG_ACTIVITY_NEW_TASK：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">App.getContext().startActivity(intent);</span><br></pre></td></tr></table></figure><p>这样就可以正常启动了，这时系统为它创建了一个新的任务栈，并且是以standard模式启动的。</p><h3 id="singleTop：栈顶复用模式"><a href="#singleTop：栈顶复用模式" class="headerlink" title="singleTop：栈顶复用模式"></a>singleTop：栈顶复用模式</h3><p>这种模式下，待启动的Activity如果位于任务栈的栈顶，那么就不会新建这个Activity的实例了。同时它的onNewIntent方法会被调用，我们可以在此方法取出当前请求信息。要注意的是，这个Activity的onCreate和onStart方法并不会被系统调用，因为它并没有发生改变。</p><p>另外一种情况是，当这个Activity并不在任务栈的栈顶，这样的话新的Activity就会被以新实例的方式创建，onCreate、onStart、onResume都会被调用。</p><h3 id="singleTask：栈内复用模式"><a href="#singleTask：栈内复用模式" class="headerlink" title="singleTask：栈内复用模式"></a>singleTask：栈内复用模式</h3><p>这种模式下，相当于单例模式。单例模式相信大家都懂，单例模式就是要确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>Activity被创建出来，肯定需要一个任务栈，singleTask模式下启动此Activity首先需要判断有没有此Activity想要的任务栈，如果不存在就创建一个任务栈，并将此Activity压到栈中。如果任务栈已经存在，并且任务栈中也存在此Activity的实例，系统就会将此Activity调到栈顶，显示出来。也就是说，待启动的Activity在任务栈中如果已经存在，无论你启动多少次这个Activity都不会创建新的实例了，此时也会只调用onNewIntent方法。</p><h3 id="singleInstance：单实例模式"><a href="#singleInstance：单实例模式" class="headerlink" title="singleInstance：单实例模式"></a>singleInstance：单实例模式</h3><p>这个模式可以理解为singleTask模式的加强版。此模式除了拥有singleTask模式所以的特性外，还有一点就是此模式的Activity只能单独的存在于一个任务栈中，由于栈内复用的特性，所以后续的请求均不会创建新的Activity实例了，除非这个任务栈被系统销毁了。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>标准模式，这个就不用多说了吧。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>适合接收通知启动的内容显示页面。</p><p>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>适合作为程序入口点。</p><p>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent方法，并且会清空主界面上面的其他页面。</p><p>多处判断弹出登录界面。</p><p>应用里面经常要根据服务器返回的用户登录状态来判断用户是否还在线，是否需要重新登录。但是当多个接口同时请求的时候，如果你的处理方式都是非在线状态下就会弹出登录的Activity，就会弹出很多个登录的Activity，用户体验很差。这时你可以将登录的Activity的launchMode设置为singleTask，就不会弹出多个同样的登录Activity了。然后就可以放心的在每个判断用户在线的地方启动登录的Activity了。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>闹铃的响铃界面。</p><p>你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面，在上午5点59分时，你在微信和朋友聊天，在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以SingleInstance加载模式打开的)，你按返回键，回到的是微信的聊天界面。这是因为 AlarmAlertActivity所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以SingleTask打开AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>关于Activity的四种启动模式介绍到此完毕~欢迎补充！另外有不足的地方，欢迎在下方评论，交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为要为了出去工作而准备面试了，所以有必要总结一下这一年多来学习Android的知识点，同时也能复习一下所学所得。有些虽然很基础，但有句老话叫“好记性不如烂笔头”。好了，废话不多说，就从基本的Activity启动模式开始。
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/source/categories/Android/"/>
    
    
      <category term="基础" scheme="http://songning.me/source/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="http://songning.me/source/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>

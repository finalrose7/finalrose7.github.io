{"meta":{"title":"SongNing's Blog","subtitle":"总会找到你想要的。","description":null,"author":"SongNing","url":"http://songning.me"},"pages":[{"title":"About","date":"2018-06-02T03:22:48.293Z","updated":"2018-05-28T14:28:33.975Z","comments":true,"path":"about/index.html","permalink":"http://songning.me/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-06-02T03:22:48.301Z","updated":"2018-05-28T14:28:33.975Z","comments":true,"path":"categories/index.html","permalink":"http://songning.me/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-02T03:22:48.310Z","updated":"2018-05-28T14:28:33.975Z","comments":true,"path":"tags/index.html","permalink":"http://songning.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一步一步教你在JCenter发布开源库","slug":"upload-to-jcenter","date":"2016-12-23T04:35:42.000Z","updated":"2017-04-02T03:34:40.000Z","comments":true,"path":"2016/12/23/upload-to-jcenter/","link":"","permalink":"http://songning.me/2016/12/23/upload-to-jcenter/","excerpt":"当你写好了一个开源库，是否也想像其他的开源库一样在Android Studio中一句compile就可以引用。比如： compile ‘com.android.support:appcompat-v7:25.1.0’","text":"当你写好了一个开源库，是否也想像其他的开源库一样在Android Studio中一句compile就可以引用。比如： compile ‘com.android.support:appcompat-v7:25.1.0’ 这看起来是一件很酷的事情，其实也不难。将你的项目上传Maven，然后发布到JCenter即可。下面我们来看看详细过程。 准备工作首先你要写好一个开源项目。嗯，不用我说你也知道。 注册Bintray说到注册，大家第一时间肯定是想到去官网注册。但是，现在官网首页的注册入口（上面第一张图）已经变成组织的注册了，并不是个人注册。所以我们要去个人注册入口： 传送门：https://bintray.com/signup/oss 在上面这个页面注册就对了。也可以用第三方登录，我是直接用Github登录（好像其它两个在我国也登录不了），省事。 创建一个Maven仓库注册完登录进去后，点击“Add New Repository”，新建仓库： 接下来，我们会看到这么一个界面： Name填maven，Type选Maven，Default Licenses选Apache-2.0，Description是描述，随便填，点击Create。然后回到主页就会在刚刚“Add New Repository”下面多了一个叫maven的仓库。 配置build.gradle在你Project的build.gradle文件中加入Maven和Jfrog Bintray的依赖插件： 1234567891011121314151617181920212223buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' //下面这两句 classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5' classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 你不一定要和我用同样版本的插件，说不定你用的时候就不是这个版本了。建议去Github上看看最新的版本： Maven：https://github.com/dcendents/android-maven-gradle-pluginJfrog Bintray：https://github.com/bintray/gradle-bintray-plugin 然后在library的build.gradle文件中进行配置，这里以我的开源控件CircleView为例： 整个build.gradle文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145apply plugin: 'com.android.library'//添加这两行apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.0\" defaultConfig &#123; minSdkVersion 14 targetSdkVersion 25 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.1.0' testCompile 'junit:junit:4.12'&#125;//项目主页def siteUrl = 'https://github.com/backkomyoung/CircleView'//项目的git地址def gitUrl = 'https://github.com/backkomyoung/CircleView.git'//发布到JCenter上的项目名字def libName = \"CircleView\"//发布到组织名称名字，必须填写group = \"me.songning.CircleView\"// 版本号，下次更新是只需要更改版本号即可version = \"1.0.0\"//上面配置后上传至JCenter后的编译路径是这样的： compile 'me.songning.CircleView:library:1.0.0'//生成源文件task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;//生成Javadoc文档task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;//文档打包成jartask javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;//拷贝javadoc文件task copyDoc(type: Copy) &#123; from \"$&#123;buildDir&#125;/docs/\" into \"docs\"&#125;//上传到JCenter所需要的源码文件artifacts &#123; archives javadocJar archives sourcesJar&#125;// 配置maven库，生成POM.xml文件install &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging 'aar' //项目描述，随意填 name 'A colorful circle view with text.' url siteUrl licenses &#123; license &#123; //开源协议 name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; //开发者的个人信息 id 'backkomyoung' name 'SongNing' email 'backkomyoung@gmail.com' &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;//上传到JCenterProperties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())bintray &#123; user = properties.getProperty(\"bintray.user\") //读取 local.properties 文件里面的 bintray.user key = properties.getProperty(\"bintray.apikey\") //读取 local.properties 文件里面的 bintray.apikey configurations = ['archives'] pkg &#123; //这里的repo值必须要和你创建Maven仓库的时候的名字一样 repo = \"maven\" //发布到JCenter上的项目名字 name = libName //项目描述 desc = 'A colorful circle view with text.' websiteUrl = siteUrl vcsUrl = gitUrl licenses = [\"Apache-2.0\"] publish = true &#125;&#125;javadoc &#123; options&#123; //如果你的项目里面有中文注释的话，必须将格式设置为UTF-8，不然会出现乱码 encoding \"UTF-8\" charSet 'UTF-8' author true version true links \"http://docs.oracle.com/javase/7/docs/api\" &#125;&#125; 除此外，还要将user和key写到local.properties文件中： 1234sdk.dir=E\\:\\\\Android\\\\Sdk//uer和keybintray.user=usernamebintray.apikey=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx user即为你的账号： key的话点击修改信息： 选择左边的“API key”，然后复制key： 把user和key填到上面的local.properties文件中就ok啦。准备工作到这里算是完成了。 执行命令打开Android Studio底部工具栏的Terminal窗口，输入命令： gradlew install 漫长的等待…可能是我的网络问题，吃了个饭回来才弄好。 显示“BUILD SUCCESSFUL”即表示成功。 到这里已经成功一半了，只差上传到Bintray了。然后我们接着在Terminal窗口输入命令： gradlew bintrayUpload 这个很快就好~ 同样，显示“BUILD SUCCESSFUL”即表示成功。 发布到JCenter这时候打开我们创建的maven仓库，就会在里面发现已经成功将项目上传到仓库里。 点击我们的项目名，进入详情： 点击“Add to JCenter”后： 直接点Send就行了。因为时差的关系，接下来就是漫长的等待审核了。 经过几个小时，在Bintray的网站上会有提示审核通过。这时候，就可以在Android Studio上通过compile的方式使用了。 遇到的问题说说我遇到的问题，就是执行上传命令的时候，显示这个错误： 提示找不到“maven”，原因是我当时还没创建Maven仓库就执行上传命令，创建后再执行一遍命令就成功了。还有就是创建的Maven仓库的名字一定要和build.gradle文件里面的repo值一致。我就遇到这一个问题。 如果你们遇到其他的问题，建议看看这篇： Android 发布项目到 JCenter 遇到的各种坑 结语到这里就把整个开源库发布到JCenter的流程写完了，有什么问题可以在下面留言~ 参考文章android 将开源项目发布到JCenter及问题总结利用Gradle发布项目到JCenter、Maven新版Bintray-极简上传Library到JCenter","categories":[{"name":"Android","slug":"Android","permalink":"http://songning.me/source/categories/Android/"}],"tags":[{"name":"JCenter","slug":"JCenter","permalink":"http://songning.me/source/tags/JCenter/"}]},{"title":"自定义View，从画个圆写个字开始","slug":"circle-view","date":"2016-12-21T12:17:18.000Z","updated":"2017-04-02T03:34:26.000Z","comments":true,"path":"2016/12/21/circle-view/","link":"","permalink":"http://songning.me/2016/12/21/circle-view/","excerpt":"前言老早以前就开始看关于自定义View的文章了，这两天实践了一下以前看的有关自定义View的知识，画了个控件。这个控件虽然看起来简单，但自定义View的基本用法都用到了。麻雀虽小，五脏俱全，所以还是记录一下过程。","text":"前言老早以前就开始看关于自定义View的文章了，这两天实践了一下以前看的有关自定义View的知识，画了个控件。这个控件虽然看起来简单，但自定义View的基本用法都用到了。麻雀虽小，五脏俱全，所以还是记录一下过程。 关于自定义View的文章，我在这墙裂推荐一下GcsSloop写的安卓自定义View教程。这是目前我认为写得比较好的关于自定义View的文章，而且很完整也很详细，通俗易懂。 那么，回归主题，就从画个不简单的圆开始吧。先看效果图，我知道没有图你们是不会往下看的。 gif图的效果有点卡顿，真机上是很流畅的。 实现过程拿到一个效果图，先看看要怎么画，思考清楚再去干活有时候会事半功倍（其实刚开始我只是打算画个圆，画着画着就越来越多了…）。我们这效果很简单，我们现在的需求只是要画个圆，然后再在上面写个字。 画个圆12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); final int paddingLeft = getPaddingLeft(); final int paddingRight = getPaddingRight(); final int paddingTop = getPaddingTop(); final int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; float centerX = paddingLeft + width / 2; float centerY = paddingTop + height / 2; float radius = Math.min(width, height) / 2; canvas.drawCircle(centerX, centerY, radius, mCirclePaint);&#125; 画圆的代码很简单，因为是继承自View，所以需要先在onDrow方法中先进行处理padding，不然padding会失效。拿到我们的View的实际的宽高后，再去获取View的中心点，用来当作圆心位置。因为我这里的画布的坐标原点在屏幕左上角，所以获取中心点的时候要加上paddingLeft和paddingTop的距离。centerX和centerY组成的点是我们布局的中心点。拿到中心点后，再根据长宽中的最小值的一半当作半径，然后就可以进行绘制圆了。So easy! 写个字drawText我们用到的是四个参数的方法，这里有个要注意的地方就是第二个参数和第三个参数并不是文字的中心位置，分别是文字左边的X值和文字底部的Y值。看下源码就知道了： 12345678910111213/** * Draw the text, with origin at (x,y), using the specified paint. The * origin is interpreted based on the Align setting in the paint. * * @param text The text to be drawn * @param x The x-coordinate of the origin of the text being drawn * @param y The y-coordinate of the baseline of the text being drawn * @param paint The paint used for the text (e.g. color, size, style) */public void drawText(@NonNull String text, float x, float y, @NonNull Paint paint) &#123; native_drawText(mNativeCanvasWrapper, text, 0, text.length(), x, y, paint.mBidiFlags, paint.getNativeInstance(), paint.mNativeTypeface);&#125; 那么这个baseline又是什么？baseline就是文字底部的Y值。看看下面这张图你就明白了： 想要把文字放在圆的中心位置，先要找到baseline和文字的左边X值。 12345678private void drawVerticalText(Canvas canvas, float centerX, float centerY, String text) &#123; Paint.FontMetrics fontMetrics = mVerticalTextPaint.getFontMetrics(); float baseLine = -(fontMetrics.ascent + fontMetrics.descent) / 2; float textWidth = mVerticalTextPaint.measureText(text); float startX = centerX - textWidth / 2; float endY = centerY + baseLine; canvas.drawText(text, startX, endY, mVerticalTextPaint);&#125; 网上有很多关于drawText的文章，不过多数是用一个Rect包裹着再画，我这里是直接画。画字在这里我封装成了一个方法，从画笔中拿到FontMetrics对象，用来获取文字的属性，包括Ascent值和Descent值等。然后计算baseline，用Paint的measureText方法获取文字的长度。最后根据中心点偏移一下把文字放到中间，ok。看一下效果： 文字竖排这时，又有个需求，我想要文字竖排显示怎么弄？第一反应想到的是drawText是不是应该有个可以控制方向的方法或参数？然而，并没有这么容易。drawText并不能竖排画文字，那么drawTextOnPath方法是不是可以呢？在圆的竖直方向建一条路径，但是结果并不是很理想，图我就不放了。最后想到的是用StaticLayout这个类，通过换行来实现竖排，其实TextView源码中也用到了这个来换行。来看主要代码： 12345678...mHorizontalTextPaint = new TextPaint(mVerticalTextPaint); mStaticLayout = new StaticLayout(mText, mHorizontalTextPaint, 1, Layout.Alignment.ALIGN_CENTER, 1.0f, 0.0f, false);... private void drawHorizontalText(Canvas canvas, float centerX, float centerY) &#123; canvas.translate(centerX, centerY - mStaticLayout.getHeight() / 2); mStaticLayout.draw(canvas); &#125; StaticLayout的构造方法第二个参数需要传个TextPaint进去，TextPaint是继承自Paint，所以可以直接传个我们上面画水平方向文字的时候的Paint对象进去就行了，就不用重新设置颜色字体大小等属性。关于StaticLayout的构造方法的参数是什么作用我这就不详细说了，我们主要看第三个参数。这个参数代表超过多少个字符就换行，这里我们传个1代表一个就换行。然后把画布X轴移动到圆心坐标，文字的高度的一半为圆心Y轴的值。这样，我们就实现了文字竖排： 文字任意角度继续加需求，要求文字45°斜着显示该怎么弄？这个简单，把画布坐标旋转不就可以了吗~ 12canvas.rotate(mAngle, centerX, centerY);drawText(canvas, centerX, centerY); 调用画布的rotate方法就可以了，就一行代码。但是这里要注意的是在drawText前面旋转画布后再drawText，一定要在drawText前面旋转画布！不然是没效果的，我在这就跳进坑里了T.T 在drawText后才旋转画布，一直没反应。还以为是哪里出错了。 旋转静态的文字头像有点单调了，那就加个动画吧。好，说加就加，加个旋转的吧。 12345678910111213141516171819202122232425262728293031323334public void startRotateAnimation() &#123; if (mAnimator == null) &#123; initRotateAnimation(); &#125; if (!mAnimator.isRunning()) &#123; mAnimator.start(); &#125;&#125;private void initRotateAnimation() &#123; if (mRotateOrientation == ROTATE_CLOCKWISE) &#123; mRotateValues = 360f; &#125; else if (mRotateOrientation == ROTATE_ANTICLOCKWISE) &#123; mRotateValues = -360f; &#125; mAnimator = ValueAnimator.ofFloat(0f, mRotateValues); mAnimator.setInterpolator(new LinearInterpolator()); mAnimator.setDuration(mSpeed); mAnimator.addUpdateListener(this); mAnimator.setRepeatCount(ValueAnimator.INFINITE); mAnimator.setRepeatMode(ValueAnimator.RESTART);&#125;@Overridepublic void onAnimationUpdate(ValueAnimator animation) &#123; mAngle = (float) animation.getAnimatedValue(); invalidate();&#125;public void stopRotateAnimation() &#123; if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125;&#125; 关于旋转动画的主要就这四个方法。原理是用属性动画ValueAnimator动态线性均匀改变一个0到360浮点值，在AnimatorUpdateListener的onAnimationUpdate方法获取范围值，mAngle为上面任意角度文字的值，动态改变这个值，不断重绘界面，就可以实现文字的旋转动画了。至于上面的360f和-360f是用来控制方向的，顺时针或者逆时针旋转。通过持续时间setDuration来控制速度。转起来： 缩放看到FloatingActionButton自带的show和hide的动画，这里我也仿照着弄了个。 12345678910111213141516171819202122public void show() &#123; if (!isShow) &#123; scaleAnimation(0.0f, 1.0f, 300); isShow = true; &#125;&#125;public void hide() &#123; if (isShow) &#123; scaleAnimation(1.0f, 0.0f, 300); isShow = false; &#125;&#125;private void scaleAnimation(float start, float end, long duration) &#123; ObjectAnimator animatorX = ObjectAnimator.ofFloat(this, \"scaleX\", start, end); ObjectAnimator animatorY = ObjectAnimator.ofFloat(this, \"scaleY\", start, end); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(duration); animatorSet.playTogether(animatorX, animatorY); animatorSet.start();&#125; 同样是通过属性动画ObjectAnimator，去缩放X轴方向“scaleX”，和Y轴方向“scaleY”。把两个动画放到一个动画集AnimatorSet里面同时执行，从0f到1f是显示，1f到0f是隐藏。 结语至此，这个文字头像控就控件就写完了。其实没什么很难的地方，只是把自定义View的基本流程写了一遍。对于学习自定义View，光看是不行的，一定要实践，动手后发现也没想象中的那么难。 同时，我将这个CircleView封装了一下发布到了JCenter，免得重复造轮子。 项目地址：https://github.com/backkomyoung/CircleView 喜欢就点个Star吧！","categories":[{"name":"Android","slug":"Android","permalink":"http://songning.me/source/categories/Android/"}],"tags":[{"name":"自定义View","slug":"自定义View","permalink":"http://songning.me/source/tags/自定义View/"}]},{"title":"优雅的使用MVP+RxJava+Retrofit框架","slug":"mvp-rxjava-retrofit","date":"2016-11-09T08:34:09.000Z","updated":"2017-04-02T03:33:40.000Z","comments":true,"path":"2016/11/09/mvp-rxjava-retrofit/","link":"","permalink":"http://songning.me/2016/11/09/mvp-rxjava-retrofit/","excerpt":"前面我已经写过一篇关于Google的RxJava版MVP解读的文章，本篇就是我在此基础上进行了修改和封装，稍微变化一下，见上图。目的是让这个框架更加实用，同时简化操作，少写代码。","text":"前面我已经写过一篇关于Google的RxJava版MVP解读的文章，本篇就是我在此基础上进行了修改和封装，稍微变化一下，见上图。目的是让这个框架更加实用，同时简化操作，少写代码。果然程序员都是喜欢偷懒的- - 前言首先，阅读本篇文章前，建议你先去了解一下MVP这个设计模式。当然，也可以先看看我前面的文章^_^ 传送门 另外，还用到了RxJava、Retrofit、Okhttp。如果你已经了解了他们的基本用法，请直接忽略这段，接着往下看~ 不想看长长的文章的，可以直接看代码。代码地址已经上传到Github，传送门。 工程结构按照惯例，先看看工程的主要结构： 简单说一下几个主要包下的功能。首先是api包，这是存放对Retrofit进行包装的类。Base包当然是放各种Base类啦~ mvp包是将契约类Contract、Model的实现类和Presenter的实现类放一起，方便管理。其实你也可以按功能分包，个人喜好吧。ui包放一些界面的类，如Activity和Fragment。 下面正式开始~ 契约类同样也是从Contract契约类开始说起： 12345678910111213141516171819202122public interface MainContract &#123; interface View extends BaseView &#123; void showDialog(); void onSucceed(Gank data); void onFail(String err); void hideDialog(); &#125; interface Model extends BaseModel &#123; Observable&lt;Gank&gt; getGank(); &#125; abstract class Presenter extends BasePresenter&lt;View, Model&gt; &#123; public abstract void getGank(); &#125;&#125; 我们可以看到，整体上和Google的Demo差不多，都是把View和Presenter放到Contract类里面统一管理，我这里多加了个Model接口，我不推荐在Presenter进行Model操作，本来很优雅的一件事，在Presenter进行Model操作的话，感觉就差了很多，要做一个优雅的程序员。不同的地方是Model和View接口继承了BaseModel接口和BaseView接口，Presenter变成了一个抽象类，继承于BasePresenter抽象类，传入两个泛型View、Model。为啥呢？我们接着看Base包下的三个Base类。 Base类BaseModel： 12public interface BaseModel &#123;&#125; BaseView： 12public interface BaseView &#123;&#125; BasePresenter： 123456789101112131415161718192021222324public class BasePresenter&lt;V extends BaseView, M extends BaseModel&gt; &#123; protected V mView; protected M mModel; private CompositeSubscription mCompositeSubscription; protected void addSubscribe(Subscription subscription) &#123; if (mCompositeSubscription == null) &#123; mCompositeSubscription = new CompositeSubscription(); &#125; mCompositeSubscription.add(subscription); &#125; public void unSubscribe() &#123; if (mView != null) &#123; mView = null; &#125; if (mCompositeSubscription != null &amp;&amp; mCompositeSubscription.hasSubscriptions()) &#123; mCompositeSubscription.clear(); &#125; &#125;&#125; BaseModel和BaseView接口里面是空的，在这里我只是为了在BasePresenter中提供一个约束。当然，如果你有其它全局的需求，可以在里面添加一些方法。重点是BasePresenter这个抽象类，传入一个View和Model，并将其用protected关键字修饰，这样，在它的子类中就可以直接对其赋值和使用了。加入CompositeSubscription变量，是为了对RxJava进行管理。unSubscribe方法对View进行null赋值和清除Rx的Subscription（订阅），防止内存泄漏。 Presnter桥梁接下来看看这个很重要的类，作为连接Model和View的桥梁，这里又是怎么做的呢？ 123456789101112131415161718192021222324252627282930313233343536373839public class MainPresenter extends MainContract.Presenter &#123; public MainPresenter(MainContract.View view) &#123; mView = view; mModel = new MainModel(); &#125; @Override public void getGank() &#123; Subscription subscribe = mModel.getGank() .subscribe(new Subscriber&lt;Gank&gt;() &#123; @Override public void onStart() &#123; mView.showDialog(); &#125; @Override public void onCompleted() &#123; mView.hideDialog(); &#125; @Override public void onError(Throwable e) &#123; mView.onFail(e.getMessage()); onCompleted(); &#125; @Override public void onNext(Gank gank) &#123; mView.onSucceed(gank); &#125; &#125;); addSubscribe(subscribe); &#125;&#125; 构造方法传进一个View，并且new了一个Model对象，直接赋值给父类中的View和Model。然后下面复写的方法中调用Model中的方法，再将结果通过View中的方法传出去，这是很原始的MVP方式。最后addSubscribe添加到订阅队列中。 Model处理数据Model分出来，而不在Presenter处理，其实也是为了简洁，当你要处理很多数据的时候，Presenter就会变得很乱了。 123456789public class MainModel implements MainContract.Model &#123; @Override public Observable&lt;Gank&gt; getGank() &#123; return ApiEngine.getInstance().getApiService() .getGank(\"1\") .compose(RxSchedulers.&lt;Gank&gt;switchThread()); &#125;&#125; 我这里很简单，就获取ApiService对象，然后调用API。最后compose传进我自己定义的线程切换器： 1234567891011121314public class RxSchedulers &#123; public static &lt;T&gt; Observable.Transformer&lt;T, T&gt; switchThread() &#123; return new Observable.Transformer&lt;T, T&gt;() &#123; @Override public Observable&lt;T&gt; call(Observable&lt;T&gt; tObservable) &#123; return tObservable .subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); &#125; &#125;; &#125;&#125; 将网络请求的IO线程切换回Android的UI主线程，才能继续进行在Presenter中的操作。 BaseActivity中的封装在前面我们可以看到BasePresenter中有两个方法，一个是添加订阅addSubscribe，另一个是unSubscribe解除订阅。我们只看到了在Presenter中使用了addSubscribe，而没有看到unSubscribe在哪使用了。因为要防止内存泄漏，所以当然要在和生命周期相关的地方进行释放资源，这个地方只有我们所说的View了，也就是Activity和Fragment中。我们先开看一下相关代码： 12345678910111213141516171819202122public abstract class BaseActivity&lt;P extends BasePresenter&gt; extends AppCompatActivity &#123; protected P mPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (onCreatePresenter() != null) &#123; mPresenter = onCreatePresenter(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mPresenter!=null)&#123; mPresenter.unSubscribe(); &#125; &#125; protected abstract P onCreatePresenter();&#125; 通过泛型确定一个Presenter的类型，然后使用抽象方法onCreatePresenter对其进行赋值，最后在onDestroy方法中进行资源的释放。继承这个BaseActivity类的Activity，就不用每次都在onDestroy进行同样的操作啦~达到简洁的目的。同理，Fragment中也是同样的，只是在生命周期的onResume和onPause中分别进行Presenter的赋值和资源的释放。这里我就不贴代码，可以上我的Github看。 Retrofit引擎封装说到这了，就顺便说一下Retrofit吧。上面的MainModel类中用到了ApiEngine类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ApiEngine &#123; private volatile static ApiEngine apiEngine; private Retrofit retrofit; private ApiEngine() &#123; //日志拦截器 HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(); loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); //缓存 int size = 1024 * 1024 * 100; File cacheFile = new File(App.getContext().getCacheDir(), \"OkHttpCache\"); Cache cache = new Cache(cacheFile, size); OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(12, TimeUnit.SECONDS) .writeTimeout(12, TimeUnit.SECONDS) .writeTimeout(12, TimeUnit.SECONDS) .addNetworkInterceptor(new NetworkInterceptor()) .addInterceptor(loggingInterceptor) .cache(cache) .build(); retrofit = new Retrofit.Builder() .baseUrl(ApiService.BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); &#125; public static ApiEngine getInstance() &#123; if (apiEngine == null) &#123; synchronized (ApiEngine.class) &#123; if (apiEngine == null) &#123; apiEngine = new ApiEngine(); &#125; &#125; &#125; return apiEngine; &#125; public ApiService getApiService() &#123; return retrofit.create(ApiService.class); &#125;&#125; 用了单例模式，在构造方法中只初始化一次Retrofit和Okhttp。双重锁的方式获取单例，然后再根据需要获取ApiService，如果你有很多个不同源的API，那就可以创建多个getXXXXApiService。 结语最后，来看看Demo运行效果吧： Demo数据源来自Gank.io 其实还有一个问题，就是关于错误类型的统一处理。刚开始的时候我是打算添加进去的，但是后来想想，每个项目的API都有不同的需求，有不同的错误，所以，还是留给需要的时候再封装一层错误处理吧。如果要统一处理错误，自定义一个Subscriber，在里面的onError方法处理即可。 至此，对于MVP的改良封装到此结束啦~ 如有什么问题，欢迎评论交流。","categories":[{"name":"Android","slug":"Android","permalink":"http://songning.me/source/categories/Android/"}],"tags":[{"name":"MVP","slug":"MVP","permalink":"http://songning.me/source/tags/MVP/"},{"name":"RxJava","slug":"RxJava","permalink":"http://songning.me/source/tags/RxJava/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://songning.me/source/tags/Retrofit/"},{"name":"框架","slug":"框架","permalink":"http://songning.me/source/tags/框架/"}]},{"title":"Google官方MVP框架源码解读","slug":"google-rxjava-mvp","date":"2016-11-03T07:54:41.000Z","updated":"2016-11-10T08:00:08.000Z","comments":true,"path":"2016/11/03/google-rxjava-mvp/","link":"","permalink":"http://songning.me/2016/11/03/google-rxjava-mvp/","excerpt":"最近在看关于MVP框架的封装，于是网上搜了一下，发现了谷歌官方的MVP Demo，发现还是Google的看着顺眼，上图为Demo的框架图。于是就对其分析了一下。Google的MVP版本很多，不过","text":"最近在看关于MVP框架的封装，于是网上搜了一下，发现了谷歌官方的MVP Demo，发现还是Google的看着顺眼，上图为Demo的框架图。于是就对其分析了一下。Google的MVP版本很多，不过思想都一样，所以就拿当前较火的RxJava那个MVP版本进行分析。 工程结构首先我们来看一下整个工程里面的包的结构： 整个工程结构不难，除了data层是处理数据外，其他都是按功能分模块。 接口类我们挑其中的一个addedittask模块来看，可以看到里面有个叫AddEditTaskContract的类，这个类是干嘛用的呢？ 这就是和普通的MVP结构不同的地方： 12345678910111213141516171819202122public interface AddEditTaskContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void showEmptyTaskError(); void showTasksList(); void setTitle(String title); void setDescription(String description); boolean isActive(); &#125; interface Presenter extends BasePresenter &#123; void saveTask(String title, String description); void populateTask(); &#125;&#125; Contract字面意思是契约，这个契约类的作用是把View层和Presenter层的接口包装起来，方便管理，同时也减少了接口文件的数量。BaseView传了个Presenter的泛型进去，我们接下来看看BaseView和BasePresenter: 12345public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; 1234567public interface BasePresenter &#123; void subscribe(); void unsubscribe();&#125; BaseView中只有一个方法setPresenter，这个方法的作用是获取Presenter对象，方便在View层使用（如在Activity和Fragment中）。看见BasePresenter中的两个方法，是不是就想到了RxJava里的订阅和解除订阅？没错，在这里还真的是这个意思。 下面，就开始介绍它们的实现类了~ 接口的实现Presenter实现类首先是实现了AddEditTaskContract.Presenter接口的AddEditTaskPresenter类，先看参数： 1234567891011121314@NonNullprivate final TasksDataSource mTasksRepository;@NonNullprivate final AddEditTaskContract.View mAddTaskView;@NonNullprivate final BaseSchedulerProvider mSchedulerProvider;@Nullableprivate String mTaskId;@NonNullprivate CompositeSubscription mSubscriptions; 其中TasksDataSource是数据源，AddEditTaskContract.View是View对象，BaseSchedulerProvider是订阅提供者（用于线程切换），CompositeSubscription可以理解为RxJava的订阅管理者，在适当的时候解除订阅防止内存泄漏。 然后看构造方法：123456789101112public AddEditTaskPresenter(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView, @NonNull BaseSchedulerProvider schedulerProvider) &#123; mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository, \"tasksRepository cannot be null!\"); mAddTaskView = checkNotNull(addTaskView, \"addTaskView cannot be null!\"); mSchedulerProvider = checkNotNull(schedulerProvider, \"schedulerProvider cannot be null!\"); mSubscriptions = new CompositeSubscription(); mAddTaskView.setPresenter(this);&#125; 构造方法传进来了三个主要的参数，同时初始化了CompositeSubscription。注意看，上面BaseView中提到的setPresenter方法在这里用到了，就是获取当前对象，也就是Presenter对象。至于构造方法中传进来的对象怎么来的，我们等下在View层会详细讲。 剩下的就是接口实现的方法了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic void subscribe() &#123; if (mTaskId != null) &#123; populateTask(); &#125;&#125;@Overridepublic void unsubscribe() &#123; mSubscriptions.clear();&#125;/** * 省略部分代码 */@Overridepublic void populateTask() &#123; if (mTaskId == null) &#123; throw new RuntimeException(\"populateTask() was called but task is new.\"); &#125; Subscription subscription = mTasksRepository .getTask(mTaskId) .subscribeOn(mSchedulerProvider.computation()) .observeOn(mSchedulerProvider.ui()) .subscribe(new Observer&lt;Task&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; if (mAddTaskView.isActive()) &#123; mAddTaskView.showEmptyTaskError(); &#125; &#125; @Override public void onNext(Task task) &#123; if (mAddTaskView.isActive()) &#123; mAddTaskView.setTitle(task.getTitle()); mAddTaskView.setDescription(task.getDescription()); &#125; &#125; &#125;); mSubscriptions.add(subscription);&#125; 我们主要看subscribe、unsubscribe和populateTask方法。在subscribe方法中进行初始化数据，调用了populateTask方法添加订阅和获取数据。unsubscribe方法中进行解除订阅。在populateTask方法中，返回数据的地方调用了View的接口，将数据传给View层。至此，整个Presenter算是讲完啦。我们接下来看到View层，也就是Activity或者Fragment。 View实现类先看代码，下面的代码我们只看重要的部分，所以省略了很多，想看完整的可以下载Google官方完整的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class AddEditTaskFragment extends Fragment implements AddEditTaskContract.View &#123; private AddEditTaskContract.Presenter mPresenter; /*...*/ @Override public void onResume() &#123; super.onResume(); mPresenter.subscribe(); &#125; @Override public void onPause() &#123; super.onPause(); mPresenter.unsubscribe(); &#125; @Override public void setPresenter(@NonNull AddEditTaskContract.Presenter presenter) &#123; mPresenter = checkNotNull(presenter); &#125; /*...*/ @Override public void showEmptyTaskError() &#123; Snackbar.make(mTitle, getString(R.string.empty_task_message), Snackbar.LENGTH_LONG).show(); &#125; @Override public void showTasksList() &#123; getActivity().setResult(Activity.RESULT_OK); getActivity().finish(); &#125; @Override public void setTitle(String title) &#123; mTitle.setText(title); &#125; @Override public void setDescription(String description) &#123; mDescription.setText(description); &#125; @Override public boolean isActive() &#123; return isAdded(); &#125;&#125; 首先，AddEditTaskFragment实现了AddEditTaskContract.View接口。然后在onResume和onPause这两个关系生命周期的地方进行了和Presenter的绑定（防止内存泄漏），在setPresenter方法中获取Presenter实例。再看下面一堆的View接口中定义的方法，就是得到数据后用来进行界面操作了啦~ Activity上面说到AddEditTaskPresenter的构造方法中的参数怎么来的，因为是RxJava的MVP版本，就顺带说一下吧。因为整个工程是多Activity+多Fragment的结构，其实是在Activity中创建了Fragment对象，然后添加到布局中的。我们看一下AddEditTaskActivity的代码： 12345678910111213141516171819202122232425262728293031323334353637383940public class AddEditTaskActivity extends AppCompatActivity &#123; public static final int REQUEST_ADD_TASK = 1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.addtask_act); /*...*/ AddEditTaskFragment addEditTaskFragment = (AddEditTaskFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame); String taskId = null; if (addEditTaskFragment == null) &#123; addEditTaskFragment = AddEditTaskFragment.newInstance(); if (getIntent().hasExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID)) &#123; taskId = getIntent().getStringExtra( AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID); actionBar.setTitle(R.string.edit_task); &#125; else &#123; actionBar.setTitle(R.string.add_task); &#125; ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), addEditTaskFragment, R.id.contentFrame); &#125; // Create the presenter new AddEditTaskPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment, Injection.provideSchedulerProvider()); &#125; /*...*/&#125; 创建了AddEditTaskFragment对象，然后添加到布局中。最后new了一个AddEditTaskPresenter，这才是重点。到这里，不禁有一个问题，AddEditTaskPresenter构造方法的第二个和第四个参数是哪来的？我们再看Injection类就知道了： 123456789101112public class Injection &#123; public static TasksRepository provideTasksRepository(@NonNull Context context) &#123; checkNotNull(context); return TasksRepository.getInstance(FakeTasksRemoteDataSource.getInstance(), TasksLocalDataSource.getInstance(context, provideSchedulerProvider())); &#125; public static BaseSchedulerProvider provideSchedulerProvider() &#123; return SchedulerProvider.getInstance(); &#125;&#125; 文章都快看完了，都说MVP，Model层在哪里呢？看上面代码中的provideTasksRepository方法，其实这就相当于Model层，获取到数据后传给Presenter，只不过用了一个数据源的名字，功能都一样。provideSchedulerProvider方法是获取一个RxJava的线程调度器： 12345678910111213141516171819202122232425262728293031323334public class SchedulerProvider implements BaseSchedulerProvider &#123; @Nullable private static SchedulerProvider INSTANCE; // Prevent direct instantiation. private SchedulerProvider() &#123; &#125; public static synchronized SchedulerProvider getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new SchedulerProvider(); &#125; return INSTANCE; &#125; @Override @NonNull public Scheduler computation() &#123; return Schedulers.computation(); &#125; @Override @NonNull public Scheduler io() &#123; return Schedulers.io(); &#125; @Override @NonNull public Scheduler ui() &#123; return AndroidSchedulers.mainThread(); &#125;&#125; 这个类用了懒汉式获取单例（看源码还是有收获的^_^），实现了BaseSchedulerProvider接口： 1234567891011public interface BaseSchedulerProvider &#123; @NonNull Scheduler computation(); @NonNull Scheduler io(); @NonNull Scheduler ui();&#125; 一共三个线程，计算线程、IO线程、UI线程，完成了对RxJava线程管理的封装使用。 总结通过这次解读，收益良多。目前来说，MVP确实是个好框架，而且RxJava便捷的线程切换对于在Model层中进行IO操作和Presenter层的UI操作的支持，两者简直是天生一对。 对于Google官方MVP框架的源码解读到这就结束啦，下一篇将对MVP进行封装一下，让这个框架更加实用，同时简化操作，少写代码。敬请期待~","categories":[{"name":"Android","slug":"Android","permalink":"http://songning.me/source/categories/Android/"}],"tags":[{"name":"MVP","slug":"MVP","permalink":"http://songning.me/source/tags/MVP/"}]},{"title":"Java设计模式 - 单例模式","slug":"singleton-pattern","date":"2016-10-29T09:19:04.000Z","updated":"2016-10-30T07:11:26.000Z","comments":true,"path":"2016/10/29/singleton-pattern/","link":"","permalink":"http://songning.me/2016/10/29/singleton-pattern/","excerpt":"单例模式是一种很常见的设计模式，我们在各种第三方库的源码中经常可以看见它的身影。单例的本质是控制实例的数量，全局有且只有一个对象，并且能够全局访问。虽然它很“小”，但作用却很大。","text":"单例模式是一种很常见的设计模式，我们在各种第三方库的源码中经常可以看见它的身影。单例的本质是控制实例的数量，全局有且只有一个对象，并且能够全局访问。虽然它很“小”，但作用却很大。例如可以节约系统内存资源，防止一些不必要的操作。 但凡做Java相关的编程工作，都应该要了解Java中的单例是怎么写的，常见的有几种写法，特点是什么。常见的有下面几种： 常见写法这应该是最简单的写法，也叫懒汉式： 1234567891011121314public class Singleton &#123; private static Singleton mInstance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; return mInstance; &#125;&#125; 但是这种写法有一个问题就是当多个线程同时调用getInstance方法的时候，就会产生多个实例，这样线程就会变得不安全了。 既然存在多个线程同时调用这个问题，所以我们会想到synchronized关键字似乎可以解决： 1234567891011121314public class Singleton &#123; private static Singleton mInstance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; return mInstance; &#125;&#125; synchronized同步锁可以保证这个方法只能同时被一个线程占有，这样看来好像是可以防止多个线程同时调用而产生多个实例这个问题，但是也有副作用。我们的目的其实只是在第一个初始化mInstance的时候需要锁上，而后面取用mInstance的时候，根本不需要线程同步。上面的写法是每次调用getInstance获取实例的时候都会进行同步锁检查，这无疑降低了效率，同时增加了资源的消耗。 双重检查锁写法既然上面的写法在每次getInstance的时候都检查锁，降低了效率消耗了大量资源。于是就产生了双重检查锁写法： 12345678910111213141516171819public class Singleton &#123; private static Singleton mInstance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (mInstance == null) &#123; //保证了同一时间只能只能有一个对象访问此同步块 synchronized (Singleton.class) &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; &#125; &#125; return mInstance; &#125;&#125; 只需要同步初始化mInstance的那部分代码，这样看起来好像可以了。但是，整个流程是这样的，首先给mInstance分配内存，然后调用构造方法进行初始化操作，最后才将mInstance对象指向分配的内存空间。要是初始化操作的时候花费了大量的时间，这里的顺序如果在此时被打断的话，那么mInstance对象将指向为完成初始化的mInstance的内存空间，这时就会报错了。这时，volatile关键字就登场了： 1234567891011121314151617181920public class Singleton &#123; //添加volatile关键字修饰 private volatile static Singleton mInstance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (mInstance == null) &#123; //保证了同一时间只能只能有一个对象访问此同步块 synchronized (Singleton.class) &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; &#125; &#125; return mInstance; &#125;&#125; 用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的值，相当于自动发现最新值。volatile也相当于一个微型的锁，执行的顺序就不会被打乱了，mInstance对象也不会指向未完成初始化的mInstance的内存空间，最终完成单例模式的实现。 这种方法是比较推荐用的，很多开源库都是用这种方法，我用得最多的也是这种方法。 饿汉式写法代码如下： 1234567891011public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton mInstance = new Singleton(); public static Singleton getInstance() &#123; return mInstance; &#125;&#125; 饿汉式特点是提前实例化，没有懒汉式中多线程问题，但不管我们是不是调用getInstance方法都会存在一个实例在内存中。这样会延长类的加载时间，不能传递参数，并且占用资源，造成浪费。 静态内部类写法这是在《Effective Java》中推荐的一种写法： 1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 和饿汉式有点像，但是在类加载的时候并没有初始化，只是在调用getInstance方法的时候才会从静态内部类中加载。而且没有多线程的问题，也是一种推荐的写法。 枚举写法在《Effective Java》中还看到了一种比较少见的写法，枚举： 1234567891011public enum Singleton &#123; INSTANCE; Singleton() &#123; &#125; public void doSomething() &#123; //do something... &#125;&#125; 使用的时候： 1Singleton.INSTANCE.doSomething(); 因为枚举的特性，保证了只有一个实例，而且自由序列化，线程安全。所以，也可以用枚举的方法写单例模式。 总结我们比较了几种常见的写法，最终推荐是用双重检查锁写法和静态内部类的写法。枚举虽然也可以，但是在Android开发中几乎没见过，而且Google的Android官网不建议使用enums，因为占用内存多。所以如果是Android开发，还是用双重检查锁写法或者静态内部类的写法吧。","categories":[{"name":"Java","slug":"Java","permalink":"http://songning.me/source/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://songning.me/source/tags/基础/"},{"name":"设计模式","slug":"设计模式","permalink":"http://songning.me/source/tags/设计模式/"}]},{"title":"Activity的四种启动模式","slug":"activity-launch-mode","date":"2016-10-28T13:06:30.000Z","updated":"2017-04-02T03:35:30.000Z","comments":true,"path":"2016/10/28/activity-launch-mode/","link":"","permalink":"http://songning.me/2016/10/28/activity-launch-mode/","excerpt":"因为要为了出去工作而准备面试了，所以有必要总结一下这一年多来学习Android的知识点，同时也能复习一下所学所得。有些虽然很基础，但有句老话叫“好记性不如烂笔头”。好了，废话不多说，就从基本的Activity启动模式开始。","text":"因为要为了出去工作而准备面试了，所以有必要总结一下这一年多来学习Android的知识点，同时也能复习一下所学所得。有些虽然很基础，但有句老话叫“好记性不如烂笔头”。好了，废话不多说，就从基本的Activity启动模式开始。 设置Activity的启动模式怎么设置Activity的启动模式呢？有两种方法： 在AndroidManifest.xml中，设置launchMode属性： 12345&lt;activity android:name=\".SecondActivity\" android:label=\"@string/title_activity_second\" android:launchMode=\"standard\" android:theme=\"@style/AppTheme.NoActionBar\"/&gt; 在启动Activity的时候，设置setFlags： 123Intent intent=new Intent(MainActivity.this,SecondActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);startActivity(intent); 两种设置模式的方法还是有区别的，按照惯例Java代码中的优先级肯定高于xml代码中的，如果两种都存在的话，以Java代码中的为准。另外在AndroidManifest.xml中无法设置FLAG_ACTIVITY_CLEAR_TOP标识，在Java代码中无法指定singleInstance模式。 四种模式standard：标准模式系统的默认模式，如果你没有设置启动模式的话就是这个模式。标准模式下的特点是每启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。被创建的Activity实例的生命周期正常调用，也就是onCreate、onStart、onResume都会被调用。 在这种模式下，当我们多次启动同一个Activity的时候，系统就会创建多个实例并把他们一一放到任务栈中。任务栈是一种后进先出的结构，每当我们按一下返回键的时候，就会有一个Activity出栈。另外我发现微信有很多功能都是快速点击的话会创建多个Activity，比如快速点击两下朋友圈，就会创建两个朋友圈的Activity，我不知道这是微信有意为之还是程序员疏忽了这些细节问题。 在《Android开发艺术探索》提到，如果用ApplicationContext去启动一个Activity的话，会报错。像这样： 12Intent intent=new Intent(MainActivity.this,SecondActivity.class);App.getContext().startActivity(intent); 我试了下果然报了这个错误： 1android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 这是因为standard模式下的Activity会默认进入启动它的Activity所属的任务栈，但是直接用ApplicationContext去启动它的话并没有所谓的任务栈，所以报错了。解决这个问题的方法是为待启动的Activity一个标记位FLAG_ACTIVITY_NEW_TASK： 123Intent intent=new Intent(MainActivity.this,SecondActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);App.getContext().startActivity(intent); 这样就可以正常启动了，这时系统为它创建了一个新的任务栈，并且是以standard模式启动的。 singleTop：栈顶复用模式这种模式下，待启动的Activity如果位于任务栈的栈顶，那么就不会新建这个Activity的实例了。同时它的onNewIntent方法会被调用，我们可以在此方法取出当前请求信息。要注意的是，这个Activity的onCreate和onStart方法并不会被系统调用，因为它并没有发生改变。 另外一种情况是，当这个Activity并不在任务栈的栈顶，这样的话新的Activity就会被以新实例的方式创建，onCreate、onStart、onResume都会被调用。 singleTask：栈内复用模式这种模式下，相当于单例模式。单例模式相信大家都懂，单例模式就是要确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 Activity被创建出来，肯定需要一个任务栈，singleTask模式下启动此Activity首先需要判断有没有此Activity想要的任务栈，如果不存在就创建一个任务栈，并将此Activity压到栈中。如果任务栈已经存在，并且任务栈中也存在此Activity的实例，系统就会将此Activity调到栈顶，显示出来。也就是说，待启动的Activity在任务栈中如果已经存在，无论你启动多少次这个Activity都不会创建新的实例了，此时也会只调用onNewIntent方法。 singleInstance：单实例模式这个模式可以理解为singleTask模式的加强版。此模式除了拥有singleTask模式所以的特性外，还有一点就是此模式的Activity只能单独的存在于一个任务栈中，由于栈内复用的特性，所以后续的请求均不会创建新的Activity实例了，除非这个任务栈被系统销毁了。 应用场景standard标准模式，这个就不用多说了吧。 singleTop适合接收通知启动的内容显示页面。 例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。 例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent方法，并且会清空主界面上面的其他页面。 多处判断弹出登录界面。 应用里面经常要根据服务器返回的用户登录状态来判断用户是否还在线，是否需要重新登录。但是当多个接口同时请求的时候，如果你的处理方式都是非在线状态下就会弹出登录的Activity，就会弹出很多个登录的Activity，用户体验很差。这时你可以将登录的Activity的launchMode设置为singleTask，就不会弹出多个同样的登录Activity了。然后就可以放心的在每个判断用户在线的地方启动登录的Activity了。 singleInstance闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面，在上午5点59分时，你在微信和朋友聊天，在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以SingleInstance加载模式打开的)，你按返回键，回到的是微信的聊天界面。这是因为 AlarmAlertActivity所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以SingleTask打开AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。 最后关于Activity的四种启动模式介绍到此完毕~欢迎补充！另外有不足的地方，欢迎在下方评论，交流。","categories":[{"name":"Android","slug":"Android","permalink":"http://songning.me/source/categories/Android/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://songning.me/source/tags/基础/"},{"name":"面试","slug":"面试","permalink":"http://songning.me/source/tags/面试/"}]},{"title":"第一章","slug":"first","date":"2016-10-27T12:21:04.000Z","updated":"2017-04-02T03:36:04.000Z","comments":true,"path":"2016/10/27/first/","link":"","permalink":"http://songning.me/2016/10/27/first/","excerpt":"花了一天时间，博客算是完全搭建好了。其实也没想象中的那么难，只要你爱折腾。","text":"花了一天时间，博客算是完全搭建好了。其实也没想象中的那么难，只要你爱折腾。作为一个编程人，捣鼓一个个人博客是很有必要的。为什么这么说呢，因为在捣鼓过程中，你会接触很多命令行操作，你会觉得x格满满，然后自信心爆棚。等下我要去阅读Android源码了，还写什么博客。哈哈，开个玩笑。 其实，我觉得这样简洁的环境下，更能够让人保持清醒的头脑。我想，Markdown语法可能也有这么一个设计初衷吧。一个黑白的界面，一个MarkdownPad2，两个命令行，就可以将自己的成果与别人分享…可以写博客的地方很多，例如CSDN、简书等。但是那些地方多数繁杂，不是我想要的。 之所以这么顺利的搭建好这个博客，我觉得应该是因为Hexo是基于Node.js，前段时间刚好学习了一下当前比较火的React Native，一个也是基于Node.js的开源框架，用于同时写Android端和iOS应用。所以对于npm命令还是很熟悉的，之后就是按照网上的教程，一步一步照着做就好了。 博客的意义不在于装x，更重要的是作为一个技术博客，应该要与别人分享我们发现的“新大陆”。交流也是很重要的一部分，要是哪位小伙伴愿意一起共同学习，可以联系我添加友情链接^_^ 大四了，马上要毕业，要开始准备面试了…嗯，第一篇博客，就这样。开始了。","categories":[{"name":"随想","slug":"随想","permalink":"http://songning.me/source/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://songning.me/source/tags/随想/"},{"name":"第一篇","slug":"第一篇","permalink":"http://songning.me/source/tags/第一篇/"}]}]}